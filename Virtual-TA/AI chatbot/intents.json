{
    "intents": [
      {
        "tag": "thanks",
        "patterns": [ "thanks", "thank you", "that's helpful" ],
        "responses": [ "Happy to help!", "Any Time!", "My pleasure" ]
      },
      {
        "tag": "greeting",
        "patterns": [ "hi", "hello", "how are you", "good day" ],
        "responses": [ "Hello, thanks for visiting", "Good to see you again", "Hi there, how can I help?" ],
        "context_set": []
      },
      {
        "tag": "goodbye",
        "patterns": [ "bye", "see you later", "goodbye" ],
        "responses": [ "See you later, thanks for visiting", "Have a nice day", "Bye! Come back again soon" ]
      },
      {
        "tag": "Tree",
        "patterns": [ "show the binary trie for the following collection of values: ", "show the result of inserting the value 39 into the AVL tree on the left", "show the splay tree that results from searching for value 75 in the splay tree", "show the binary tree for the following collection of values: ", "show the result of inserting the value 39 into the AVL tree on the left", "show the splay tree that results from searching for value 75 in the splay tree",  "show the binary tree for the following collection of values: ", "show the result of inserting the value 39 into the AVL tree on the left", "show the splay tree that results from searching for value 75 in the splay tree" ],
        "responses": [ "Remember that a binary tree has, as the name suggests, up to 2 branches per node.", "Consider how a tree must change its structure when its contents are modified: Will the root change? Will certain nodes stay on the same side of the root? etc.", "An AVL tree will retain a balanced, binary-tree structure. How will the tree rotate in response to the insertion/deletion?" ]
      },
      {
        "tag": "Big-O",
        "patterns": [ "which expression is slower O(n) or O(n^2)", "which expression is faster O(2n) or O(nlog(n))", "which is faster O(n^2) or O(3n)","which is faster O(n^2) or O(n)", "which is slower O(nlog(n)) or O(2^n)" ],
        "responses": [ "Consider that big-O notation describes the growth of a function.", "To compare big-O's, think of of the speeds in which your functions grow as their inputs tend to infinity.", "Remember that big-O representations of functions can be simplified.", "Big-O comparisons only care about the simplest representation of the function since that determines the speed of their growth." ]
      },
      {
        "tag": "sorting",
        "patterns": ["shellsort worst case is", "the best case of mergesort","the average runtime of quicksort","heapsort","radix sort","binsort","bucket sort","counting sort","cubesort"],
        "responses": [ "The speed of Quicksort is dependent on how you select a pivot.", "Shellsort performs best when the data is mostly sorted, but generally within O(n^2).", "Remember that Radixsort is a non-comparison sort that processes individual digits.", "Heapsort achieves efficiency by, as the name suggests, utilizing the 'heap' data structure. This guarantees that the root node of the heap is the largest (or smallest) element." ]
      }
    ]
  }